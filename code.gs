/**
 * This script generates agenda notes for 1:1 meetings.
 * It takes the content from a 1:1 meeting template and add it to documents
 * based on a dictionary.
 * It search for recurrences in the calendar and if there is a meeting scheduled,
 * the document is update with the notes from the template
 */

// Set up the required constants
const CALENDAR_ID = 'replace for your calendar id'; 
const TEMPLATE_DOC_ID = 'replace for your template doc id';

// Array of objects with the event id and doc id for each one for reports.
// eventId can be obtained using the identifier from the event url and pass it through a base64 decode 
// like https://www.base64decode.org/ but taking only the first part, before _time
const AGENDA_EVENTS = [
  {
    eventId: 'replace for eventId', 
    targetDoc: 'replace for agenda doc for that event'
  }
];


/**
 * The main function
 */
function run() {
  const eventsToProcess = getAgendaEventsInNextWeekEvents();
  //const eventsToProcess = getAgendaEventsInThisWeekEvents();

  eventsToProcess.forEach(event => {
    addMeetingNotesToDoc(event.calendarEvent, event.settings.targetDoc);
    sendNotification(event.calendarEvent, event.settings.targetDoc);
  })
}

/**
 * Send email notification with link to the document
 * @todo make the type of email to send configurable, at the moment is two different functions, one for all and another just for creator
 * 
 * @param event google class CalendarEvent
 * @param targetDocId The id of the agenda google document
 */
function sendNotification(event, targetDocId) {
  const emailProperties = {};

  const formattedDate = Utilities.formatDate(event.getStartTime(),'GMT','yyyy-MM-dd');
  emailProperties.subject = `[Action required] The agenda for ${formattedDate} | ${event.getTitle()} is ready`;

  const targetDocLink = `https://docs.google.com/document/d/${targetDocId}`;

  emailProperties.message = "<p>I'm looking forward for our 1:1 on " + formattedDate + "</p>" +
                            "<p>Please take some time to review and add content to the agenda in " + targetDocLink + "</p><br>" +
                            "<p style=\"font-style: italic;\">This email was <a href=\"https://github.com/nmicht/automate-1to1-agenda\">autogenerated</a></p>";
  
  //emailEventAttendees(event, emailProperties);
  emailCreator(event, emailProperties);
}

/**
 * Send an email to all the guests, including the creator, no matter if attending or not
 * 
 * @param event google class CalendarEvent
 * @param emailProperties object with subject and message for the email
 */
function emailEventAttendees(event, emailProperties) {

  // Get the list of attendees including creator
  var attendees = event.getGuestList(true);
  var recipientEmails = [];

  // Collect all attendees' emails
  for (var i = 0; i < attendees.length; i++) {
    var attendee = attendees[i];
    recipientEmails.push(attendee.getEmail());
  }

  // Send the email to all recipients
  for (var j = 0; j < recipientEmails.length; j++) {
    var email = recipientEmails[j];
    GmailApp.sendEmail(email, emailProperties.subject, emailProperties.message, { htmlBody: emailProperties.message });
  }

  Logger.log("Emails sent successfully to: " + recipientEmails.join(', '));
}

/**
 * Send an email to the creator, no matter if attending or not
 * 
 * @param event google class CalendarEvent
 * @param emailProperties object with subject and message for the email
 */
function emailCreator(event, emailProperties) {

  // Get the creator
  var creatorEmail = event.getCreators()[0];

  GmailApp.sendEmail(creatorEmail, emailProperties.subject, emailProperties.message, { htmlBody: emailProperties.message });

  Logger.log("Emails sent successfully to: " + recipientEmails.join(', '));
}

/**
 * Pulls the content from a template and copy it into the target agenda doc
 * 
 * @param event google class CalendarEvent
 * @param targetDocId The id of the agenda google document
 */
function addMeetingNotesToDoc(event, targetDocId) {
  const targetDoc = DocumentApp.openById(targetDocId);
  const targetBody = targetDoc.getBody();

  // Index to insert elements in the doc based on the last meeting - secont title
  let index = findLastMeetingTitle(DocumentApp.ParagraphHeading.HEADING2,targetDocId)

  // Insert Title
  const formattedDate = Utilities.formatDate(event.getStartTime(),'GMT','yyyy-MM-dd');
  const titleParagraph = `${formattedDate} | ${event.getTitle()}`;
  const title = targetBody.insertParagraph(index++,titleParagraph).setHeading(DocumentApp.ParagraphHeading.HEADING2);
  const notesParagraph = targetBody.insertParagraph(index++, 'Notes');

  // Get notes template
  const templateDoc = DocumentApp.openById(TEMPLATE_DOC_ID);
  const notesBody = templateDoc.getBody();

  // Find the list in the template document
  const lists = notesBody.getListItems();

  // Iterate through each list item and copy with formatting to the destination document
  lists.forEach(listItem => {
    // Get the text and attributes of the list item
    const text = listItem.getText();
    const itemAttributes = listItem.getAttributes();

    const newItem = targetBody.insertListItem(index++, listItem.getText());

    // Apply attributes to the new paragraph in the destination document
    //applyAttributes(newItem, attributes);
    newItem.setAttributes(itemAttributes)
  });

  Logger.log(`Agenda for meeting on ${formattedDate} for ${event.getTitle()} was added`)
}

/**
 * Apply formatting to any element passed to it
 * 
 * @param element 
 * @param attributes 
 */
function applyAttributes(element, attributes) {
  // Apply each attribute to the element
  if (attributes) {
    Logger.log(attributes)
    if (attributes.NESTING_LEVEL) {
      element.setNestingLevel(attributes.NESTING_LEVEL);
    }
    if (attributes.BOLD) {
      element.setItalic(attributes.BOLD);
    }
    //if (attributes.GLYPH_TYPE) {
    //  element.setGlyphType(attributes.GLYPH_TYPE);
    //}
  }
}

/**
 * Identify the index where to start adding new notes
 * @param searchCriteria 
 * @param targetDocId 
 * @returns the index position in the doc
 */
function findLastMeetingTitle(searchCriteria, targetDocId) {
  const targetDoc = DocumentApp.openById(targetDocId);
  const body = targetDoc.getBody();
  const elements = body.getNumChildren();

  // start searching after the first element because we normally have an stack section
  for (let i = 1; i < elements; i++) {
    let item = body.getChild(i);
    if (item.getHeading() == searchCriteria) {
      return i;
    }
  }
}

/**
 * Get all the calendar events in the next week based on 7 days from now
 * @returns array of events
 */
function getAgendaEventsInNextWeekEvents() {
  const now = new Date();
  const startOfNextWeek = new Date(now.getFullYear(), now.getMonth(), now.getDate() + (7 - now.getDay()));
  startOfNextWeek.setUTCHours(0,0,0,0);
  const endOfNextWeek = new Date(startOfNextWeek.getFullYear(), startOfNextWeek.getMonth(), startOfNextWeek.getDate() + 7);

  //console.log(`Getting events in next week, starting on ${startOfNextWeek} and finishing on ${endOfNextWeek}`);

  const nextWeekEvents = getEvents(startOfNextWeek, endOfNextWeek);

  return nextWeekEvents;
}

/**
 * Get all calendar events in the current week
 * @returns array of events
 */
function getAgendaEventsInThisWeekEvents() {
  const now = new Date();
  var day = now.getDay();
  var diff = now.getDate() - day + (day == 0 ? -6 : 1); // adjust when day is sunday
  const startOfThisWeek = new Date(now.setDate(diff));
  startOfThisWeek.setUTCHours(0,0,0,0);
  const endOfThisWeek = new Date(startOfThisWeek.getFullYear(), startOfThisWeek.getMonth(), startOfThisWeek.getDate() + 5);
  
  //console.log(`Getting events in this week, starting on ${startOfThisWeek} and finishing on ${endOfThisWeek}`);

  const thisWeekEvents = getEvents(startOfThisWeek, endOfThisWeek);

  return thisWeekEvents;
}

/**
 * Filter all the events to get only those that are part of the global AGENDA_EVENTS and where the creator or the guest haven't declined
 * @param startDate 
 * @param endDate 
 * @returns array of events
 */
function getEvents(startDate, endDate) {
  const nextEvents = CalendarApp.getCalendarById(CALENDAR_ID).getEvents(startDate, endDate);

  const foundEvents = [];

  // Iterate over nextEvents and find matching agendaEvents
  for (let nextEvent of nextEvents) {
    for (let agendaEvent of AGENDA_EVENTS) {
      if (nextEvent.getId().startsWith(agendaEvent.eventId)) {
        
        if (isCreatorDeclined(nextEvent) === true || isGuestDeclined(nextEvent) === true) {
          Logger.log(`Skiping event ${nextEvent.getTitle()} because creator or guest declined`)
          continue;
        }
        
        foundEvents.push({
          settings: agendaEvent,
          calendarEvent: nextEvent
        });
        break; // Break inner loop once a match is found
      }
    }
  }

  Logger.log(`Found ${foundEvents.length} events to process`)

  return foundEvents;
}

/**
 * Determine if the creator of an event has declined
 * @param event 
 * @returns boolean, true if declined
 */
function isCreatorDeclined(event) {
  // Get the organizer's email address
  var creatorEmail = event.getCreators()[0];

  // Get the list of attendees including creator
  var attendees = event.getGuestList(true);

  // Check the response status of the creator
  for (var i = 0; i < attendees.length; i++) {
    var attendee = attendees[i];

    //console.log(`Did Creator Declined? Comparing creator: ${creatorEmail} with attendee: ${attendee.getEmail()} where attendee replied as ${attendee.getGuestStatus()}`);

    if (attendee.getEmail() === creatorEmail) {
      if (attendee.getGuestStatus() === CalendarApp.GuestStatus.YES) {
        return false; // Creator is attending
      } else if (attendee.getGuestStatus() === CalendarApp.GuestStatus.NO) {
        return true; // Creator declined
      }
    }
  }

  // If creator's status is not found, assume is attending
  return false;
}

/**
 * Determine if the guest of an event has declined
 * @param event 
 * @returns boolean, true if declined
 */
function isGuestDeclined(event) {
  // Get the list of attendees
  var attendees = event.getGuestList();

  // Check the response status of the guest that is not creator
  for (var i = 0; i < attendees.length; i++) {
    var attendee = attendees[i];

    //console.log(`Did Guest Declined? Comparing attendee: ${attendee.getEmail()} where attendee replied as ${attendee.getGuestStatus()}`);

    if (attendee.getGuestStatus() === CalendarApp.GuestStatus.YES) {
      return false; // Guest is attending
    } else if (attendee.getGuestStatus() === CalendarApp.GuestStatus.NO) {
      return true; // Guest declined
    }
  }

  // If guest's status is not found, assume is attending
  return false;
}